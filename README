A graph application for Drscheme

Implementation notes

First and foremost, this project is being made to address problems
with what we already have, the swl-based grid search. In order to do
this, I propose the following goals.

* Persistent window

  We want to remove the annoyance of having to open and close windows
  when running our search programs. Therefore, the window should be
  persistent.

  In the interest of keeping the application simple, rather than
  having a complicated infrastructure to send closures to a running
  graph application as previously proposed, we'll have the application
  start from the repl, and keep the repl thread running. Then the user
  can push their functions onto a stack of functions which the
  application steps forward every n frames according to the speed
  slider. This may require some continuation passing and the macros to
  hide it.

* GUI interface
  - There should be a slider to control the speed
  - You should be able to place players with the mouse
  - There should be pause/play buttons and a button to clear the screen
  - If it's not too much work: a rewind button
  - Some buttons to switch between graph layouts, perhaps a graph
    history as well.

  I have spent some time implementing the user interface, and it is
  very close to how I'd like to keep it. All that's left to add is a
  few usability features.

  A few keybinds would be useful, such as spacebar to start/stop the
  process, number keys to switch quickly between graphs. Perhaps a
  keybind to save/load a list of graphs. We should also display the
  number of the current graph in the list of graphs. Aesthetically
  speaking, I'd like this number to be drawn at the bottom of the
  canvas area, but then we'd have to avoid overlap with the graph. We
  could deal with this by adding more padding.

* Under the hood
  
  Rather than represent the grid as a 2D matrix, I want to move to
  representing the grid as a graph data structure, most likely an
  adjacency matrix. So obstacles do not even appear on the graph, and
  are only denoted by a lack of connectivity. Though this makes
  drawing more complex, it also make it more flexible, as any graph
  has an infinite number of graphical representations, and our graphs
  are no longer limited to square grids. We can import real-world map
  data and have students search through it.

  Using an adjacency matrix also allows us to implement weighted
  graphs in a clean way, using #f to represent absence of a connection
  and a scalar value to represent a weight representing the cost to
  travel along an edge.
  
  We will make it easy to swap graph generation functions in and out,
  so students can try making different kinds of graphs.

  As much as possible I'd like to stick to the R5RS scheme standard,
  and avoid using PLT specific functions outside of the actual
  graphical program. We want students to be able to develop however
  they like, using whatever implementation they like (the actual GUI
  being an exception, obviously)

  We want to keep the grid data structure immutable. That will allow
  us to run multiple search functions at the same time and implement
  races and competitions very easily. Each search function is
  responsible for keeping a list of notable vertices, though we may
  provide some functions that make it easier.

  Another thing that I would like to provide are queues and stacks
  that display their contents in another window, updated real time so
  students can see what is going on.

